---
-
  name: "Block to Allow Loading of Variables without running task"
  when: run_tasks
  block:
    -
      name: "Checking if JEDI has been installed"
      register: domino_jedi_installed
      ansible.builtin.stat:
        path: "{{ completed_dir }}/domino_jedi_installed"
        get_md5: false
      
    -
      name:  "Disabling the nashed service to prevent conflict with JeDI"
      when: domino_jedi_installed.stat.exists
      ansible.builtin.service:
        name: domino
        enabled: false
        state: stopped

    -
      name: "Enabling and start JeDI service"
      when: domino_jedi_installed.stat.exists
      ansible.builtin.systemd:
        name: "{{ jedi_service }}"
        enabled: true
        state: started

    -
      name: "Setting up i386 Architecture Support"
      when: not domino_jedi_installed.stat.exists
      become: true
      block:
        -
          name: "Gathering DEB architecture"
          ansible.builtin.shell: dpkg --print-architecture
          register: deb_architecture
    
        -
          name: "Printing DEB architecture"
          ansible.builtin.debug:
            msg: "deb_architecture.stdout: {{ deb_architecture.stdout }}"
    
        -
          name: "Printing i386 setup information"
          ansible.builtin.debug:
            msg: "Setting up i386 architecture support for 32-bit libraries"
    
        -
          name: "Adding i386 architecture (if not already added)"
          ansible.builtin.shell: |
            dpkg --print-foreign-architectures | grep -w i386 || dpkg --add-architecture i386
          register: add_arch_result
          changed_when: add_arch_result.rc == 0
    
        -
          name: "Getting foreign architectures after adding i386"
          ansible.builtin.shell: dpkg --print-foreign-architectures
          register: foreign_arch_post
    
        -
          name: "Printing foreign architectures after adding i386"
          ansible.builtin.debug:
            msg: "foreign_arch_post.stdout_lines: {{ foreign_arch_post.stdout_lines }}"
    
        -
          name: "Installing i386 packages"
          ansible.builtin.apt:
            name:
              - libc6:i386
              - libstdc++6:i386
            state: present
            update_cache: true
            
        -
          name: "Verifying 32-bit libc by checking /lib/ld-linux.so.2"
          ansible.builtin.shell: |
            if [ -x /lib/ld-linux.so.2 ]; then
              echo "32-bit libc loader works correctly"
            else
              echo "32-bit libc loader is missing or not functional" && exit 1
            fi
          register: verify_libc32
          failed_when: verify_libc32.rc != 0
          changed_when: false

        -
          name: "Debugging 32-bit libc verification result"
          ansible.builtin.debug:
            msg: "{{ verify_libc32.stdout }}"

        -
          name: "Installing C development tools"
          ansible.builtin.apt:
            name:
              - build-essential
              - cmake
              - pkg-config
              - libssl-dev
              - git
            state: present
            update_cache: false

        -
          name: "Ensuring {{ prominic_install_dir }} parent directories exist"
          ansible.builtin.file:
            path: "{{ prominic_install_dir }}"
            state: directory
            mode: '0755'
            owner: '{{ service_user }}'
            group: '{{ service_group }}'

        # Copy JediWeb to vm
        # try installers/jedi/jediweb.zip at first, if not present, then {{ role_path }}/files/jediweb
        # if still not present, then download from url  {{ jediweb_online_zip }} and extract to target

        # -
        #   name: "Checking if JediWeb.zip exists"
        #   ansible.builtin.stat:
        #     path: "{{ prominic_install_dir }}/jediweb.zip"
        #     remote_src: false
        #   register: jediweb_zip_stat

        # -
        #   name: "Showing source for JediWeb.zip"
        #   ansible.builtin.debug:
        #     msg: "Checking if JediWeb.zip exists in {{ prominic_install_dir }}"
        #   when: jediweb_zip_stat.stat.exists == false

        # -
        #   name: "Checking if JediWeb.zip exists"
        #   ansible.builtin.stat:
        #     path: "{{ jediweb_local_zip }}"
        #   register: jediweb_zip_stat

        # # TODO, finish it just like jedi

        # -
        #   name: "Checking if JediWeb.zip exists"
        #   ansible.builtin.stat:
        #     path: "{{ prominic_install_dir }}/jediweb.zip"
        #     remote_src: false
        #   register: jediweb_zip_stat

        # -
        #   name: "Showing source for JediWeb.zip"
        #   ansible.builtin.debug:
        #     msg: "Checking if JediWeb.zip exists in {{ prominic_install_dir }}"
        #   when: jediweb_zip_stat.stat.exists == false

        # -
        #   name: "Checking if JediWeb.zip exists in local source"
        #   ansible.builtin.stat:
        #     path: "{{ jediweb_local_zip }}"
        #   register: jediweb_local_zip_stat

        # -
        #   name: "Copying JediWeb.zip to {{ prominic_install_dir }}"
        #   ansible.builtin.copy:
        #     src: "{{ jediweb_local_zip }}"
        #     dest: "{{ prominic_install_dir }}/jediweb.zip"
        #     remote_src: false
        #     mode: '0644'
        #   when: jediweb_local_zip_stat.stat.exists == true

        # -
        #   name: "Downloading JediWeb.zip from URL if not found locally"
        #   ansible.builtin.get_url:
        #     url: "{{ jediweb_online_zip }}"
        #     dest: "{{ prominic_install_dir }}/jediweb.zip"
        #     mode: '0644'
        #   when: jediweb_zip_stat.stat.exists == false and jediweb_local_zip_stat.stat.exists == false

        # -
        #   name: "Extracting JediWeb.zip to {{ prominic_install_dir }}"
        #   ansible.builtin.unarchive:
        #     src: "{{ prominic_install_dir }}/jediweb.zip"
        #     dest: "{{ prominic_install_dir }}"
        #     remote_src: true
        #   when: jediweb_zip_stat.stat.exists == true

        # -
        #   name: "Copying local  JediWeb to {{ prominic_install_dir }}"
        #   ansible.builtin.copy:
        #     src: "{{ role_path }}/files/JediWeb/"
        #     dest: "{{ prominic_install_dir }}/"
        #     remote_src: false
        #     mode: preserve
        #     recursive: true
        #   when: jediweb_local_zip_stat.stat.exists == true

        # --- End of JediWeb TODO ---

        # Copy jedi to vm
        # try installers/jedi/jedi.zip at first, if not present, then {{ role_path }}/files/jedi
        # if still not present, then download from url  {{ jedi_online_zip }}   and extract to target

        # -
        #   name: "Checking if jedi.zip exists"
        #   ansible.builtin.stat:
        #     path: "{{ prominic_install_dir }}/jedi.zip"
        #   register: jedi_zip_stat

        # -
        #   name: "Showing source for jedi.zip"
        #   ansible.builtin.debug:
        #     msg: "Checking if jedi.zip exists in {{ prominic_install_dir }}"
        #   when: jedi_zip_stat.stat.exists == false

        # -
        #   name: "Checking if jedi.zip exists"
        #   ansible.builtin.stat:
        #     path: "{{ jedi_local_zip }}"
        #   register: jedi_zip_stat

        # -
        #   name: "Checking if jedi directory exists"
        #   ansible.builtin.stat:
        #     path: "{{ jedi_local_unpack_dir }}"
        #   register: jedi_dir_stat

        # -
        #   name: "Showing if jedi.zip exists"
        #   ansible.builtin.debug:
        #     msg: "jedi.zip exists at {{ jedi_local_zip }}"
        #   when: jedi_zip_stat.stat.exists == true

        # -
        #   name: "Showing if jedi directory exists"
        #   ansible.builtin.debug:
        #     msg: "jedi directory exists at {{ jedi_local_unpack_dir }}"
        #   when: jedi_dir_stat.stat.exists == true

        # -
        #   name: "Copying jedi.zip from installers to {{ prominic_install_dir }}"
        #   ansible.builtin.copy:
        #     src: "{{ jedi_local_zip }}"
        #     dest: "{{ prominic_install_dir }}/"
        #     remote_src: false
        #     mode: preserve
        #   when: jedi_zip_stat.stat.exists == false
        #   remote_src: true
        #   register: copy_jedi_zip

        # -
        #   name: "Downloading jedi.zip from URL if not found"
        #   ansible.builtin.get_url:
        #     url: "{{ jedi_online_zip }}"
        #     dest: "{{ prominic_install_dir }}/jedi.zip"
        #     mode: '0644'
        #   when: jedi_zip_stat.stat.exists == false and not copy_jedi_zip.changed
        #   ignore_errors: true
        #   register: download_jedi_zip

        # -
        #   name: "Copying jedi directory to {{ prominic_install_dir }}"
        #   ansible.builtin.copy:
        #     src: "{{ role_path }}/files/jedi/"
        #     dest: "{{ prominic_install_dir }}/"
        #     remote_src: false
        #     mode: preserve
        #   when: jedi_zip_stat.stat.exists == false and not download_jedi_zip.changed
        #   ignore_errors: true
        #   register: copy_jedi_directory

        # -
        #   name: "Extracting jedi.zip to {{ prominic_install_dir }}"
        #   ansible.builtin.unarchive:
        #     src: "{{ prominic_install_dir }}/jedi.zip"
        #     dest: "{{ prominic_install_dir }}/"
        #     remote_src: true
        #     creates: "{{ prominic_install_dir }}/jedi"
        #   when: jedi_zip_stat.stat.exists == false
        #   ignore_errors: true
        #   register: extract_jedi_zip

        # Handlers to display specific messages
        # handlers:
        #   - name: "Showing copied jedi.zip source"
        #     ansible.builtin.debug:
        #       msg: "Jedi.zip copied from the role path: {{ role_path }}/files/jedi.zip"
    
        #   - name: "Showing downloaded jedi.zip source"
        #     ansible.builtin.debug:
        #       msg: "Jedi.zip downloaded from URL: {{ jedi_online_zip }}"
    
        #   - name: "Showing copied jedi directory"
        #     ansible.builtin.debug:
        #       msg: "Jedi directory copied from role path: {{ role_path }}/files/jedi/"
    
        #   - name: "Echo extracted jedi.zip content"
        #     ansible.builtin.debug:
        #       msg: "Jedi.zip extracted to {{ prominic_install_dir }}"

        -
          name: "Including the failover files logic to copy jedi to target"
          import_tasks: failoverfiles.yaml
          vars:
              failover_url: "{{ jedi_online_zip }}"
              failover_localzip: "{{ jedi_local_zip }}"
              failover_localdir: "{{ jedi_local_unpack_dir }}"
              failover_app_name: "jedi"
              failover_destdir: "{{ prominic_install_dir }}"

        -
          name: "Setting ownership of {{ prominic_install_dir }}/jedi to domino"
          ansible.builtin.file:
            path: "{{ prominic_install_dir }}/jedi"
            state: directory
            mode: '0755'
            owner: '{{ service_user }}'
            group: '{{ service_group }}'
            recurse: true

        # JAR file - install this separately
        -
          name: "Checking if JeDI JAR was provided"
          stat:
            path: "{{ jedi_local_jar }}"
          register: test_jar_file
          ignore_errors: true

        -
          name: "Downloading the JeDI JAR if it is not provided locally"
          get_url:
            url: "{{ jedi_online_jar }}"
            dest: "{{ jedi_local_jar }}"
          when: not test_jar_file.stat.exists
          ignore_errors: false

        -
          name: "Copying JeDI JAR to {{ jedi_install_jar }}"
          ansible.builtin.copy:
            src: "{{ jedi_local_jar }}"
            dest: "{{ jedi_install_jar }}"
            
        -
          name: "Copying jedic directory to {{ prominic_install_dir }}"
          ansible.builtin.copy:
            src: "{{ role_path }}/files/jedic"
            dest: "{{ prominic_install_dir }}/"
            remote_src: false  # Ensures files are copied from local role directory
            mode: preserve

        -
          name: "Setting ownership of {{ prominic_install_dir }}/jedi to domino"
          ansible.builtin.file:
            path: "{{ prominic_install_dir }}/jedi"
            state: directory
            mode: '0755'
            owner: '{{ service_user }}'
            group: '{{ service_group }}'
            recurse: true

        -
          name: "Ensuring {{ jedi_noteslog }} exists"
          ansible.builtin.file:
            path: '{{ jedi_noteslog }}'
            state: directory
            mode: '0755'
            owner: '{{ service_user }}'
            group: '{{ service_group }}'

        -
          name: Ensuring domino_user and domino_group are defined
          set_fact:
            domino_user: "{{ domino_user | default('domino') }}"
            domino_group: "{{ domino_group | default('domino') }}"

        -
          name: "Setting ownership of {{ jedi_noteslog }} to domino_user"
          ansible.builtin.file:
            path: '{{ jedi_noteslog }}'
            state: directory
            mode: '0755'
            owner: '{{ domino_user }}'
            group: '{{ domino_group }}'
            recurse: true

        -
          name: "Running make -f Makefile64 in jedic directory"
          ansible.builtin.command:
            cmd: make -f Makefile64
            chdir: "{{ role_path }}/files/jedic"

        -
          name: "Ensuring {{ prominic_install_dir }}/jedi/lib/Linux64 exists"
          ansible.builtin.file:
            path: "{{ prominic_install_dir }}/jedi/lib/Linux64"
            state: directory
            mode: '0755'
            owner: '{{ service_user }}'
            group: '{{ service_group }}'

        -
          name: "Copying libunixruntime.so to {{ prominic_install_dir }}/jedi/lib/Linux64"
          ansible.builtin.copy:
            src: "{{ role_path }}/files/jedic/libunixruntime.so"
            dest: "{{ prominic_install_dir }}/jedi/lib/Linux64/"
            remote_src: false
            mode: '0644'
            owner: '{{ service_user }}'
            group: '{{ service_group }}'

        -
          name: "Updating partitions.xml using template"
          ansible.builtin.template:
            src: partitions.xml.j2
            dest: "{{ jedi_cfg_dir }}/partitions.xml"
            mode: '0744'
            owner: '{{ service_user }}'
            group: '{{ service_group }}'

        -
          name: "Updating jdi.cfg using template"
          ansible.builtin.template:
            src: jdi.cfg.j2
            dest: "{{ jedi_cfg_dir }}/jdi.cfg"
            mode: '0744'
            owner: '{{ service_user }}'
            group: '{{ service_group }}'

        -
          name: "Updating users.cfg using template - defines user credentials"
          ansible.builtin.template:
            src: users.cfg.j2
            dest: "{{ jedi_cfg_dir }}/users.cfg"
            mode: '0744'
            owner: '{{ service_user }}'
            group: '{{ service_group }}'

        -
          name: "Updating acl.cfg using template - controls admin rights for users"
          ansible.builtin.template:
            src: acl.cfg.j2
            dest: "{{ jedi_cfg_dir }}/acl.cfg"
            mode: '0744'
            owner: '{{ service_user }}'
            group: '{{ service_group }}'

        -
          name: "Generating ssl.cfg using the local certificates"
          when: jedi_ssl_update
          ansible.builtin.template:
            src: ssl.cfg.j2
            dest: "{{ jedi_cfg_dir }}/ssl.cfg"
            mode: '0644'
            owner: '{{ service_user }}'
            group: '{{ service_group }}'

        -
          name: "Updating start script"
          ansible.builtin.template:
            src: jedi.j2
            dest: "{{ jedi_install_dir }}/bin/jedi"
            mode: '0744'
            owner: '{{ service_user }}'
            group: '{{ service_group }}'
        -
          name: "Adding Environment file for service"
          ansible.builtin.template:
            src: environment.j2
            dest: "{{ jedi_cfg_dir }}/environment"
            mode: '0744'
            owner: '{{ service_user }}'
            group: '{{ service_group }}'

        -
          name: "Creating systemd service for JeDI"
          ansible.builtin.template:
            src: jedi.service.j2
            dest: "/etc/systemd/system/{{ jedi_service }}.service"
            mode: '0744'
            owner: '{{ service_user }}'
            group: '{{ service_group }}'

        -
          name: "Reloading systemd to recognize new service"
          ansible.builtin.command: systemctl daemon-reload

        -
          name:  "Disabling the nashed service to prevent conflict with JeDI"
          ansible.builtin.service:
            name: domino
            enabled: false
            state: stopped

        -
          name: "Enabling and start JeDI service"
          ansible.builtin.systemd:
            name: "{{ jedi_service }}"
            enabled: true
            state: started

        -
          name: "Add console alias for service user"
          when: jedi_alias.enabled
          ansible.builtin.lineinfile:
            path: "/home/{{ service_user }}/.bashrc"
            line: "alias '{{ jedi_alias.alias }}'='{{ jedi_alias.command }}'"
            regexp: '^alias {{ jedi_alias.alias }}='
            state: present
            create: true
            owner: "{{ service_user }}"
            group: "{{ service_group }}"

        -
          name: "Setting JEDI as installed"
          when: not domino_jedi_installed.stat.exists
          ansible.builtin.file:
            mode: '0644'
            path: "{{ item }}"
            state: touch
            owner: '{{ service_user }}'
            group: '{{ service_group }}'
          with_items:
            - "{{ completed_dir }}/domino_jedi_installed"
